*** a/position_manager.py
--- b/position_manager.py
@@
 from core.bybit_exchange import create_exchange, normalize_symbol
 from core.market_info import adjust_qty_price
 from core.trade_log import append_trade_event
-from core.indicators import atr_latest_from_ohlcv
+from core.indicators import atr_latest_from_ohlcv
 
@@
 def open_position(symbol: str, side: str, price: Optional[float] = None) -> Dict[str, Any]:
@@
-    # –¶–µ–Ω–∞ (–µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏)
+    # –¶–µ–Ω–∞ (–µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏)
     if price is None:
         t = ex.fetch_ticker(sym)
         price = float(t.get("last") or t.get("close") or 0.0)
+    # –û–∫—Ä—É–≥–ª—ë–Ω–Ω–∞—è —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞ –ø–æ —Ç–∏–∫-—à–∞–≥—É
+    px = float(ex.price_to_precision(sym, price))
 
-    # –†–∏—Å–∫-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã
-    risk_fraction = float(os.getenv("RISK_FRACTION", "0.2"))
-    leverage = int(os.getenv("LEVERAGE", "3"))
-    tp_pct = float(os.getenv("TP_PCT", "0.01"))
-    sl_pct = float(os.getenv("SL_PCT", "0.005"))
+    # –†–∏—Å–∫/–ø–ª–µ—á–æ
+    leverage = int(os.getenv("LEVERAGE", "3"))
 
-
-    # ATR-–±–∞–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∏—Å–∫
-    ex_atr = create_exchange()
-    ohlcv = ex_atr.fetch_ohlcv(sym, timeframe=os.getenv("TIMEFRAME", "5m"), limit=200)
-    
-    atr, _last = atr_latest_from_ohlcv(ohlcv, period=int(os.getenv("ATR_PERIOD", "14")))
-    sl_mult = float(os.getenv("SL_ATR_MULT", "1.8"))
-    stop_dist = max(atr * sl_mult, 1e-9)
-    risk_pct = float(os.getenv("RISK_PCT", "0.007"))  # 0.7% –æ—Ç –±–∞–ª–∞–Ω—Å–∞
-    risk_usdt = max(1e-6, usdt * risk_pct)
-    qty_raw = (risk_usdt / stop_dist)  # —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –æ—Ç —Ä–∏—Å–∫–∞
+    # ATR-–±–∞–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∏—Å–∫ –∏ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
+    tf = os.getenv("TIMEFRAME", "5m")
+    ohlcv = ex.fetch_ohlcv(sym, timeframe=tf, limit=200)
+    atr, _last = atr_latest_from_ohlcv(ohlcv, period=int(os.getenv("ATR_PERIOD", "14")))
+    sl_mult = float(os.getenv("SL_ATR_MULT", "1.8"))          # SL = sl_mult * ATR
+    tp_mult = float(os.getenv("TP_ATR_MULT", "2.2"))          # TP = tp_mult * ATR
+    stop_dist = max(atr * sl_mult, 1e-9)                      # –¥–∏—Å—Ç–∞–Ω—Ü–∏—è SL –æ—Ç –≤—Ö–æ–¥–∞
+    risk_pct = float(os.getenv("RISK_PCT", "0.007"))          # 0.7% –∫–∞–ø–∏—Ç–∞–ª–∞ –Ω–∞ —Å–¥–µ–ª–∫—É
+    risk_usdt = max(1e-6, usdt * risk_pct)
+    # –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –æ—Ç —Ä–∏—Å–∫–∞ (–≤ –±–∞–∑–æ–≤–æ–π –≤–∞–ª—é—Ç–µ)
+    qty_raw = risk_usdt / stop_dist if stop_dist > 0 else 0.0
+
+    # –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
+    order_side = "buy" if side.lower() == "long" else "sell"
+
+    # –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ qty –∏ —Ü–µ–Ω—ã –∫ —à–∞–≥–∞–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
+    qty, px, _ = adjust_qty_price(sym, qty_raw, px)
+    if qty <= 0:
+        return {
+            "status": "error",
+            "reason": "qty<=0 after adjust",
+            "balance": usdt,
+            "qty_raw": qty_raw,
+        }
 
-
-    # TP/SL —Ü–µ–Ω—ã
-    if order_side == "buy":
-        sl_price = float(ex.price_to_precision(sym, px - stop_dist))
-        tp_price = float(ex.price_to_precision(sym, px + float(os.getenv("TP_ATR_MULT", "2.2")) * atr))
-    else:
-        sl_price = float(ex.price_to_precision(sym, px + stop_dist))
-        tp_price = float(ex.price_to_precision(sym, px - float(os.getenv("TP_ATR_MULT", "2.2")) * atr))
-
-        # –û—Ç–ª–∞–¥–∫–∞
+    # TP/SL —Ü–µ–Ω—ã –æ—Ç ATR
+    if order_side == "buy":
+        sl_price = float(ex.price_to_precision(sym, px - stop_dist))
+        tp_price = float(ex.price_to_precision(sym, px + tp_mult * atr))
+    else:
+        sl_price = float(ex.price_to_precision(sym, px + stop_dist))
+        tp_price = float(ex.price_to_precision(sym, px - tp_mult * atr))
+
+    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ä–¥–µ—Ä–∞ (Bybit v5)
+    params = {"takeProfit": tp_price, "stopLoss": sl_price}
+
+    # –û—Ç–ª–∞–¥–∫–∞
     print(
         "üîé DEBUG ORDER:",
         {
             "symbol": sym,
             "side": order_side,
             "qty_raw": qty_raw,
             "qty": qty,
             "entry_price": px,
             "TP": tp_price,
             "SL": sl_price,
             "lev": leverage,
         },
     )
 
     try:
-        # –†–∞–∑–º–µ—â–µ–Ω–∏–µ
+        # –ü–ª–µ—á–æ (110043 ‚Äî –Ω–µ–∫—Ä–∏—Ç–∏—á–Ω–æ)
+        try:
+            ex.set_leverage(leverage, sym)
+        except Exception as e:
+            if "110043" not in str(e):
+                print("‚ö†Ô∏è set_leverage:", e)
+
+        # –†–∞–∑–º–µ—â–µ–Ω–∏–µ
         o = ex.create_order(sym, type="market", side=order_side, amount=qty, price=None, params=params)
@@
-        # –£—Å–ø–µ—Ö
+        # –£—Å–ø–µ—Ö
         return {
             "status": (o.get("status") or "unknown"),
             "order": o,
             "qty": qty,
             "price": px,
             "tp": tp_price,
             "sl": sl_price,
             "balance": usdt,
         }
*** a/positions_guard.py
--- b/positions_guard.py
@@
-from core.indicators import atr_latest_from_ohlcv
-
 from core.bybit_exchange import normalize_symbol, create_exchange
 from core.env_loader import load_and_check_env
@@
-from core.trailing_stop import (
-    update_trailing_for_symbol, 
-    verify_trailing_state, 
-    set_stop_loss_only, 
-    compute_atr, 
-    set_trailing_stop_ccxt, 
-    compute_trailing_from_atr, 
-    move_stop_loss, 
-    maybe_breakeven
-)
+from core.trailing_stop import (
+    update_trailing_for_symbol,
+    verify_trailing_state,
+    set_stop_loss_only,
+    compute_atr,
+)
 from position_manager import open_position
-from core.indicators import compute_snapshot, atr_latest_from_ohlcv
+from core.indicators import compute_snapshot
@@
             res = open_position(sym, side=signal)
             print("üßæ –†–µ–∑—É–ª—å—Ç–∞—Ç:", res)
             apply_trailing_after_entry(sym, signal, res, dry_run)
-
-            # –ø–æ—Å–ª–µ print("üßæ –†–µ–∑—É–ª—å—Ç–∞—Ç:", res)
-            if not dry_run and isinstance(res, dict) and res.get("status") not in {"error", "retryable"}:
-                try:
-                    ex_ts = create_exchange()
-                    # 1) –ø–æ–ª—É—á–∞–µ–º OHLCV –∏ ATR
-                    ohlcv = ex_ts.fetch_ohlcv(sym, timeframe=args.timeframe, limit=max(args.limit, 200))
-                    atr, last_close = atr_latest_from_ohlcv(ohlcv, period=int(os.getenv("ATR_PERIOD", "14")))
-                    entry_px = float(res.get("price") or last_close or 0.0)
-                    side = "long" if str(res.get("side") or "").lower() in ("buy", "long") else "short"
-
-                    # 2) –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ ENV
-                    k_act = float(os.getenv("TS_ACTIVATION_ATR_K", "1.0"))
-                    min_up = float(os.getenv("TS_ACTIVATION_MIN_UP_PCT", "0.001"))
-                    min_dn = float(os.getenv("TS_ACTIVATION_MIN_DOWN_PCT", "0.001"))
-                    auto_cb = os.getenv("TS_CALLBACK_RATE_AUTO", "1") == "1"
-                    cb_k = float(os.getenv("TS_CALLBACK_RATE_ATR_K", "0.75"))
-                    cb_fixed = float(os.getenv("TS_CALLBACK_RATE", "1.0"))
-
-                    active, cb_pct = compute_trailing_from_atr(entry_px, side, atr,
-                                                   k_activate=k_act, min_up_pct=min_up, min_down_pct=min_dn,
-                                                   cb_from_atr_k=cb_k, cb_fixed_pct=cb_fixed, auto_cb=auto_cb)
-                    print("[TS_CALL]", {"symbol": sym, "side": side, "entry": entry_px, "atr": atr, "active": active, "cb%": cb_pct})
-                    set_trailing_stop_ccxt(ex_ts, sym, activation_price=active, callback_rate=cb_pct,
-                               category="linear", tpsl_mode="Full", position_idx=0, trigger_by="LastPrice")
-                    print("[TS_OK]")
-                except Exception as e:
-                    print("[TS_ERR]", e)
 
*** a/core/trailing_stop.py
--- b/core/trailing_stop.py
@@
-import os
-import time
-import logging
-from typing import Dict, Any, List
-
-logger = logging.getLogger("trailing_stop")
-
-try:
-    import ccxt  # type: ignore
-except Exception:
-    ccxt = None
-
-_RATE_DELAY = float(os.getenv("BYBIT_RATE_LIMIT_DELAY", "0.4"))  # 3 rps ~= 0.33s
-
-
-# ---------------- helpers ----------------
-def _market_id(exchange, unified_symbol: str) -> str:
-    """BTC/USDT:USDT -> BTCUSDT (id –¥–ª—è Bybit v5)."""
-    exchange.load_markets(reload=False)
-    m = exchange.market(unified_symbol)
-    return m["id"]
-
-
-def _assert_ok(resp: Dict[str, Any]) -> None:
-    """–ü–æ–¥–Ω–∏–º–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ Bybit –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É; 110043 —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ OK."""
-    rc = resp.get("retCode")
-    if rc in (0, "0", None):
-        return
-    if str(rc) == "110043":  # not modified
-        logger.warning("Bybit retCode=110043 (not modified) ‚Äî —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ OK")
-        return
-    raise RuntimeError(f"Bybit error retCode={rc}, retMsg={resp.get('retMsg')}, result={resp.get('result')}")
-
-
-def _fetch_ohlcv(exchange, symbol: str, timeframe: str, limit: int) -> List[List[float]]:
-    # ohlcv: [ts, open, high, low, close, volume]
-    return exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
-
-
-def _sma(vals: List[float], period: int) -> float:
-    n = len(vals)
-    if n < period or period <= 0:
-        return sum(vals) / max(1, n)
-    return sum(vals[-period:]) / float(period)
-
-
-def compute_atr(
-    exchange,
-    symbol: str,
-    timeframe: str = "5m",
-    period: int = 14,
-    *,
-    limit: int | None = None
-) -> tuple[float, float]:
-    """
-    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (atr, last_close).
-
-    ATR (Wilder, SMA):
-      TR = max(high - low, |high - prev_close|, |low - prev_close|)
-      ATR = SMA(TR, period)
-    """
-    if limit is None:
-        limit = max(period + 1, 100)
-
-    ohlcv = _fetch_ohlcv(exchange, symbol, timeframe, limit)
-    if len(ohlcv) < period + 1:
-        last_close = float(ohlcv[-1][4]) if ohlcv else 0.0
-        return 0.0, last_close
-
-    true_ranges: list[float] = []
-    for i in range(1, len(ohlcv)):
-        high = float(ohlcv[i][2])
-        low = float(ohlcv[i][3])
-        prev_close = float(ohlcv[i - 1][4])
-        tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
-        true_ranges.append(tr)
-
-    atr = _sma(true_ranges, period)
-    last_close = float(ohlcv[-1][4])
-    return float(atr), last_close
-
-
-# --------------- core API wrappers ---------------
-def set_trailing_stop_ccxt(
-    exchange,
-    symbol: str,
-    activation_price: float,
-    callback_rate: float = 1.0,
-    *,
-    category: str = "linear",
-    tpsl_mode: str = "Full",
-    position_idx: int = 0,          # 0(one-way), 1(Long), 2(Short)
-    trigger_by: str = "LastPrice",
-    max_retries: int = 3,
-) -> Dict[str, Any]:
-    """
-    POST /v5/position/trading-stop —á–µ—Ä–µ–∑ ccxt (privatePostV5PositionTradingStop).
-    –í–ê–ñ–ù–û: —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ‚Äî —Å—Ç—Ä–æ–∫–∞–º–∏.
-    """
-    bybit_symbol = _market_id(exchange, symbol)
-    payload = {
-        "category": category,
-        "symbol": bybit_symbol,
-        "tpslMode": tpsl_mode,
-        "positionIdx": position_idx,
-        "trailingStop": f"{callback_rate}",     # —Å—Ç—Ä–æ–∫–∞!
-        "activePrice": f"{activation_price}",   # —Å—Ç—Ä–æ–∫–∞!
-        "tpOrderType": "Market",
-        "slOrderType": "Market",
-        "tpTriggerBy": trigger_by,
-        "slTriggerBy": trigger_by,
-    }
-    attempt = 0
-    while True:
-        attempt += 1
-        try:
-            resp = exchange.privatePostV5PositionTradingStop(payload)
-            _assert_ok(resp)
-            time.sleep(_RATE_DELAY)  # –±–∞–∑–æ–≤–∞—è –ø–∞—É–∑–∞ –ø—Ä–æ—Ç–∏–≤ 10006/429
-            return resp
-        except Exception as e:
-            msg = str(e)
-            if "10006" in msg or "rate limit" in msg.lower():
-                if attempt >= max_retries:
-                    raise
-                backoff = min(_RATE_DELAY * (2 ** (attempt - 1)), 2.0)
-                logger.warning("[TS][RETRY %d] rate limit, sleep=%.2fs", attempt, backoff)
-                time.sleep(backoff)
-                continue
-            raise
-
-
-def verify_trailing_state(exchange, symbol: str, *, category: str = "linear") -> Dict[str, Any]:
-    """GET /v5/position/list ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–µ–∫—É—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∑–∏—Ü–∏–∏ (–≤–∫–ª—é—á–∞—è trailingStop/stopLoss)."""
-    bybit_symbol = _market_id(exchange, symbol)
-    return exchange.privateGetV5PositionList({"category": category, "symbol": bybit_symbol})
-
-
-def set_stop_loss_only(
-    exchange, symbol: str, stop_price: float,
-    *, category: str = "linear", position_idx: int = 0, trigger_by: str = "LastPrice"
-) -> Dict[str, Any]:
-    """
-    –ü–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ StopLoss —á–µ—Ä–µ–∑ —Ç–æ—Ç –∂–µ endpoint /v5/position/trading-stop (Full).
-    –£–¥–æ–±–Ω–æ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ –±–µ–∑—É–±—ã—Ç–æ–∫.
-    """
-    bybit_symbol = _market_id(exchange, symbol)
-    payload = {
-        "category": category,
-        "symbol": bybit_symbol,
-        "positionIdx": position_idx,
-        "tpslMode": "Full",
-        "stopLoss": f"{stop_price}",
-        "slOrderType": "Market",
-        "slTriggerBy": trigger_by,
-    }
-    resp = exchange.privatePostV5PositionTradingStop(payload)
-    _assert_ok(resp)
-    time.sleep(_RATE_DELAY)
-    return resp
-
-
-# --------------- high-level: activation logic (ATR/PCT) ---------------
-def update_trailing_for_symbol(
-    exchange,
-    symbol: str,
-    entry_price: float,
-    side: str,
-    *,
-    activation_mode: str | None = None,   # atr | pct
-    atr_timeframe: str | None = None,
-    atr_period: int | None = None,
-    atr_k: float | None = None,
-    up_pct: float | None = None,
-    down_pct: float | None = None,
-    callback_rate: float | None = None,
-    auto_callback: bool | None = None,
-    auto_cb_k: float | None = None,
-) -> Dict[str, Any]:
-    """
-    –°—Ç–∞–≤–∏—Ç —Ç—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø —Å –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π:
-      mode="atr":  LONG ‚Üí entry + K*ATR ; SHORT ‚Üí entry - K*ATR
-      mode="pct":  LONG ‚Üí entry*(1+up_pct) ; SHORT ‚Üí entry*(1-down_pct)
-    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —á–∏—Ç–∞—é—Ç—Å—è –∏–∑ .env –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.
-    """
-    activation_mode = (activation_mode or os.getenv("TS_ACTIVATION_MODE", "atr")).lower()
-    atr_timeframe = atr_timeframe or os.getenv("ATR_TIMEFRAME", "5m")
-    atr_period = int(atr_period or int(os.getenv("ATR_PERIOD", "14")))
-    atr_k = float(atr_k or float(os.getenv("TS_ACTIVATION_ATR_K", "1.0")))
-
-    up_pct = float(os.getenv("TS_ACTIVATION_UP_PCT", "0.003")) if up_pct is None else up_pct
-    down_pct = float(os.getenv("TS_ACTIVATION_DOWN_PCT", "0.003")) if down_pct is None else down_pct
-    min_up_pct = float(os.getenv("TS_ACTIVATION_MIN_UP_PCT", "0.001"))
-    min_dn_pct = float(os.getenv("TS_ACTIVATION_MIN_DOWN_PCT", "0.001"))
-
-    callback_rate = float(os.getenv("TS_CALLBACK_RATE", "1.0")) if callback_rate is None else callback_rate
-    auto_callback = bool(int(os.getenv("TS_CALLBACK_RATE_AUTO", "0"))) if auto_callback is None else auto_callback
-    auto_cb_k = float(os.getenv("TS_CALLBACK_RATE_ATR_K", "0.75")) if auto_cb_k is None else auto_cb_k
-
-    side_l = (side or "").lower()
-
-    if activation_mode == "atr":
-        atr, _ = compute_atr(exchange, symbol, atr_timeframe, atr_period)
-        if atr > 0:
-            offset = atr_k * atr
-            if side_l in ("long", "buy"):
-                base = entry_price * (1.0 + min_up_pct)
-                active = max(entry_price + offset, base)
-            else:
-                base = entry_price * (1.0 - min_dn_pct)
-                active = min(entry_price - offset, base)
-            if auto_callback:
-                pct = max(atr / entry_price * 100.0 * auto_cb_k, 0.1)
-                callback_rate = max(0.1, min(pct, 5.0))  # –ª–∏–º–∏—Ç—ã Bybit
-            logger.info("[TS_ACTIVE][ATR] %s side=%s entry=%.6f atr=%.6f k=%.3f active=%.6f cb=%.3f%%",
-                        symbol, side_l, entry_price, atr, atr_k, active, callback_rate)
-        else:
-            activation_mode = "pct"
-
-    if activation_mode != "atr":
-        if side_l in ("long", "buy"):
-            active = entry_price * (1.0 + max(min_up_pct, up_pct))
-        else:
-            active = entry_price * (1.0 - max(min_dn_pct, down_pct))
-        logger.info("[TS_ACTIVE][PCT] %s side=%s entry=%.6f up=%.4f down=%.4f active=%.6f cb=%.3f%%",
-                    symbol, side_l, entry_price, up_pct, down_pct, active, callback_rate)
-
-    try:
-        active_precise = float(exchange.price_to_precision(symbol, active))
-    except Exception:
-        active_precise = active
-
-    return set_trailing_stop_ccxt(
-        exchange=exchange,
-        symbol=symbol,
-        activation_price=active_precise,
-        callback_rate=callback_rate,
-        category="linear",
-        tpsl_mode="Full",
-        position_idx=0,
-        trigger_by="LastPrice",
-    )
+import os
+import time
+import logging
+from typing import Dict, Any, List, Tuple
+
+logger = logging.getLogger("trailing_stop")
+
+try:
+    import ccxt  # type: ignore
+except Exception:
+    ccxt = None
+
+_RATE_DELAY = float(os.getenv("BYBIT_RATE_LIMIT_DELAY", "0.4"))  # –±–∞–∑–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
+
+# ---------------- helpers ----------------
+def _market_id(exchange, unified_symbol: str) -> str:
+    """BTC/USDT:USDT -> BTCUSDT (id –¥–ª—è Bybit v5)."""
+    exchange.load_markets(reload=False)
+    m = exchange.market(unified_symbol)
+    return m["id"]
+
+def _assert_ok(resp: Dict[str, Any]) -> None:
+    """–ü–æ–¥–Ω–∏–º–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ Bybit –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É; 110043 —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ OK."""
+    rc = resp.get("retCode")
+    if rc in (0, "0", None):
+        return
+    if str(rc) == "110043":  # not modified
+        logger.warning("Bybit retCode=110043 (not modified) ‚Äî —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ OK")
+        return
+    raise RuntimeError(f"Bybit error retCode={rc}, retMsg={resp.get('retMsg')}, result={resp.get('result')}")
+
+def _fetch_ohlcv(exchange, symbol: str, timeframe: str, limit: int) -> List[List[float]]:
+    return exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
+
+def _sma(vals: List[float], period: int) -> float:
+    n = len(vals)
+    if n < period or period <= 0:
+        return sum(vals) / max(1, n)
+    return sum(vals[-period:]) / float(period)
+
+def compute_atr(
+    exchange,
+    symbol: str,
+    timeframe: str = "5m",
+    period: int = 14,
+    *,
+    limit: int | None = None
+) -> Tuple[float, float]:
+    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (atr, last_close) –ø–æ Wilder/SMA."""
+    if limit is None:
+        limit = max(period + 1, 100)
+    ohlcv = _fetch_ohlcv(exchange, symbol, timeframe, limit)
+    if len(ohlcv) < period + 1:
+        last_close = float(ohlcv[-1][4]) if ohlcv else 0.0
+        return 0.0, last_close
+    trs: List[float] = []
+    for i in range(1, len(ohlcv)):
+        high = float(ohlcv[i][2]); low = float(ohlcv[i][3]); prev_close = float(ohlcv[i-1][4])
+        trs.append(max(high - low, abs(high - prev_close), abs(low - prev_close)))
+    atr = _sma(trs, period)
+    last_close = float(ohlcv[-1][4])
+    return float(atr), last_close
+
+# --------------- core API wrappers ---------------
+def set_trailing_stop_ccxt(
+    exchange,
+    symbol: str,
+    activation_price: float,
+    callback_rate: float = 1.0,
+    *,
+    category: str = "linear",
+    tpsl_mode: str = "Full",
+    position_idx: int = 0,
+    trigger_by: str = "LastPrice",
+    max_retries: int = 3,
+) -> Dict[str, Any]:
+    """POST /v5/position/trading-stop —á–µ—Ä–µ–∑ ccxt (privatePostV5PositionTradingStop)."""
+    bybit_symbol = _market_id(exchange, symbol)
+    payload = {
+        "category": category,
+        "symbol": bybit_symbol,
+        "tpslMode": tpsl_mode,
+        "positionIdx": position_idx,
+        "trailingStop": f"{callback_rate}",
+        "activePrice": f"{activation_price}",
+        "tpOrderType": "Market",
+        "slOrderType": "Market",
+        "tpTriggerBy": trigger_by,
+        "slTriggerBy": trigger_by,
+    }
+    attempt = 0
+    while True:
+        attempt += 1
+        try:
+            resp = exchange.privatePostV5PositionTradingStop(payload)
+            _assert_ok(resp)
+            time.sleep(_RATE_DELAY)
+            return resp
+        except Exception as e:
+            msg = str(e)
+            if "10006" in msg or "rate limit" in msg.lower():
+                if attempt >= max_retries:
+                    raise
+                time.sleep(min(_RATE_DELAY * (2 ** (attempt - 1)), 2.0))
+                continue
+            raise
+
+def verify_trailing_state(exchange, symbol: str, *, category: str = "linear") -> Dict[str, Any]:
+    bybit_symbol = _market_id(exchange, symbol)
+    return exchange.privateGetV5PositionList({"category": category, "symbol": bybit_symbol})
+
+def set_stop_loss_only(
+    exchange, symbol: str, stop_price: float,
+    *, category: str = "linear", position_idx: int = 0, trigger_by: str = "LastPrice"
+) -> Dict[str, Any]:
+    """–ü–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ StopLoss —á–µ—Ä–µ–∑ /v5/position/trading-stop (Full)."""
+    bybit_symbol = _market_id(exchange, symbol)
+    payload = {
+        "category": category,
+        "symbol": bybit_symbol,
+        "positionIdx": position_idx,
+        "tpslMode": "Full",
+        "stopLoss": f"{stop_price}",
+        "slOrderType": "Market",
+        "slTriggerBy": trigger_by,
+    }
+    resp = exchange.privatePostV5PositionTradingStop(payload)
+    _assert_ok(resp)
+    time.sleep(_RATE_DELAY)
+    return resp
+
+# --------------- high-level (ATR/PCT) ---------------
+def update_trailing_for_symbol(
+    exchange,
+    symbol: str,
+    entry_price: float,
+    side: str,
+    *,
+    activation_mode: str | None = None,   # atr | pct
+    atr_timeframe: str | None = None,
+    atr_period: int | None = None,
+    atr_k: float | None = None,
+    up_pct: float | None = None,
+    down_pct: float | None = None,
+    callback_rate: float | None = None,
+    auto_callback: bool | None = None,
+    auto_cb_k: float | None = None,
+) -> Dict[str, Any]:
+    """–°—Ç–∞–≤–∏—Ç —Ç—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø —Å –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π –ø–æ ATR –∏–ª–∏ %."""
+    activation_mode = (activation_mode or os.getenv("TS_ACTIVATION_MODE", "atr")).lower()
+    atr_timeframe = atr_timeframe or os.getenv("ATR_TIMEFRAME", "5m")
+    atr_period = int(atr_period or int(os.getenv("ATR_PERIOD", "14")))
+    atr_k = float(atr_k or float(os.getenv("TS_ACTIVATION_ATR_K", "1.0")))
+
+    up_pct = float(os.getenv("TS_ACTIVATION_UP_PCT", "0.003")) if up_pct is None else up_pct
+    down_pct = float(os.getenv("TS_ACTIVATION_DOWN_PCT", "0.003")) if down_pct is None else down_pct
+    min_up_pct = float(os.getenv("TS_ACTIVATION_MIN_UP_PCT", "0.001"))
+    min_dn_pct = float(os.getenv("TS_ACTIVATION_MIN_DOWN_PCT", "0.001"))
+
+    callback_rate = float(os.getenv("TS_CALLBACK_RATE", "1.0")) if callback_rate is None else callback_rate
+    auto_callback = bool(int(os.getenv("TS_CALLBACK_RATE_AUTO", "0"))) if auto_callback is None else auto_callback
+    auto_cb_k = float(os.getenv("TS_CALLBACK_RATE_ATR_K", "0.75")) if auto_cb_k is None else auto_cb_k
+
+    side_l = (side or "").lower()
+
+    if activation_mode == "atr":
+        atr, _ = compute_atr(exchange, symbol, atr_timeframe, atr_period)
+        if atr > 0:
+            offset = atr_k * atr
+            if side_l in ("long", "buy"):
+                base = entry_price * (1.0 + min_up_pct)
+                active = max(entry_price + offset, base)
+            else:
+                base = entry_price * (1.0 - min_dn_pct)
+                active = min(entry_price - offset, base)
+            if auto_callback:
+                pct = max(atr / entry_price * 100.0 * auto_cb_k, 0.1)
+                callback_rate = max(0.1, min(pct, 5.0))  # –ª–∏–º–∏—Ç—ã Bybit
+        else:
+            activation_mode = "pct"
+
+    if activation_mode != "atr":
+        if side_l in ("long", "buy"):
+            active = entry_price * (1.0 + max(min_up_pct, up_pct))
+        else:
+            active = entry_price * (1.0 - max(min_dn_pct, down_pct))
+
+    try:
+        active_precise = float(exchange.price_to_precision(symbol, active))
+    except Exception:
+        active_precise = active
+
+    return set_trailing_stop_ccxt(
+        exchange=exchange,
+        symbol=symbol,
+        activation_price=active_precise,
+        callback_rate=callback_rate,
+        category="linear",
+        tpsl_mode="Full",
+        position_idx=0,
+        trigger_by="LastPrice",
+    )
+
+def compute_trailing_from_atr(entry: float, side: str, atr: float, *,
+                              k_activate: float, min_up_pct: float, min_down_pct: float,
+                              cb_from_atr_k: float, cb_fixed_pct: float, auto_cb: bool) -> Tuple[float, float]:
+    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (activePrice, callback_rate_pct) –Ω–∞ –±–∞–∑–µ ATR."""
+    side_l = side.lower()
+    if side_l in ("long", "buy"):
+        activate = entry + max(k_activate * atr, entry * min_up_pct)
+    else:
+        activate = entry - max(k_activate * atr, entry * min_down_pct)
+    if auto_cb:
+        cb = max(0.1, min(5.0, 100.0 * (cb_from_atr_k * atr / entry)))  # 0.1%..5%
+    else:
+        cb = cb_fixed_pct
+    return float(activate), float(cb)
+
+def maybe_breakeven(entry: float, side: str, last: float, atr: float,
+                    *, be_mode: str, be_atr_k: float, be_trigger_pct: float, be_offset_pct: float) -> float | None:
+    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–Ω—É SL –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ BE –ª–∏–±–æ None."""
+    side_l = side.lower()
+    if be_mode == "atr":
+        need = be_atr_k * atr
+        in_profit = (last - entry) if side_l in ("long", "buy") else (entry - last)
+        if in_profit >= need:
+            return entry * (1.0 + be_offset_pct) if side_l in ("long", "buy") else entry * (1.0 - be_offset_pct)
+    else:
+        need = entry * be_trigger_pct
+        if (side_l in ("long", "buy") and last >= entry + need) or (side_l in ("short", "sell") and last <= entry - need):
+            return entry * (1.0 + be_offset_pct) if side_l in ("long", "buy") else entry * (1.0 - be_offset_pct)
+    return None

