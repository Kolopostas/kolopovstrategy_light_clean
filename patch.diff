*** Begin Patch
*** Update File: core/env_loader.py
@@
-import os
-from dotenv import load_dotenv
-
-def load_and_check_env(required_keys=None):
-    # –ó–∞–≥—Ä—É–∂–∞–µ–º .env –∏–∑ –∫–æ—Ä–Ω—è –ø—Ä–æ–µ–∫—Ç–∞
-    env_path = os.path.join(os.getcwd(), ".env")
-    load_dotenv(env_path, override=False)
-    if required_keys:
-        missing = [k for k in required_keys if not os.getenv(k)]
-        if missing:
-            raise RuntimeError(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ .env: {', '.join(missing)}")
-    return True
+import os
+from pathlib import Path
+from dotenv import load_dotenv
+
+def load_and_check_env(required_keys=None) -> bool:
+    """
+    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ .env:
+    - –∏—â–µ—Ç .env –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞–ø—É—Å–∫–∞ (–∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞);
+    - –Ω–µ —Ç—Ä–µ–±—É–µ—Ç PYTHONPATH-—Ö–∞–∫–æ–≤.
+    """
+    cwd_env = Path(os.getcwd()) / ".env"
+    load_dotenv(dotenv_path=cwd_env if cwd_env.exists() else None, override=False)
+    if required_keys:
+        missing = [k for k in required_keys if not os.getenv(k)]
+        if missing:
+            raise RuntimeError(f"‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ .env: {', '.join(missing)}")
+    return True
+
*** End Patch
*** Begin Patch
*** Add File: core/bybit_exchange.py
+import os
+import ccxt
+
+def create_exchange() -> ccxt.bybit:
+    """
+    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ccxt Bybit –¥–ª—è –¥–µ—Ä–∏–≤–∞—Ç–∏–≤–æ–≤ (USDT Perp).
+    –í–∞–∂–Ω–æ: defaultType='swap' –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π recvWindow.
+    """
+    proxy = os.getenv("PROXY_URL")
+    recv_window = int(os.getenv("RECV_WINDOW", "15000"))
+    exchange = ccxt.bybit({
+        "apiKey": os.getenv("BYBIT_API_KEY"),
+        "secret": os.getenv("BYBIT_SECRET_KEY"),
+        "enableRateLimit": True,
+        "options": {
+            "adjustForTimeDifference": True,
+            "recvWindow": recv_window,
+            "defaultType": "swap",
+        },
+    })
+    if proxy:
+        exchange.proxies = {"http": proxy, "https": proxy}
+    # –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º —Ä—ã–Ω–∫–∏, —á—Ç–æ–±—ã –±—ã–ª–∏ precision/limits
+    exchange.load_markets(reload=True)
+    return exchange
+
+def normalize_symbol(symbol: str) -> str:
+    """
+    –ü—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ñ–æ—Ä–º–∞—Ç—É BTC/USDT:USDT, –∫–∞–∫ –æ–∂–∏–¥–∞–µ—Ç ccxt –¥–ª—è –¥–µ—Ä–∏–≤–∞—Ç–∏–≤–æ–≤ Bybit.
+    """
+    s = symbol.upper().replace(" ", "")
+    if ":" not in s:
+        base, quote = s.split("/")
+        s = f"{base}/{quote}:{quote}"
+    return s
+
*** End Patch
*** Begin Patch
*** Update File: core/market_info.py
@@
-from typing import Dict
-from .bybit_exchange import normalize_symbol
-
-def get_filters(exchange, symbol: str) -> Dict:
-    sym = normalize_symbol(symbol)
-    market = exchange.market(sym)  # ccxt —Å–∞–º –ø–æ–¥—Ç—è–Ω–µ—Ç markets
-    price_tick = market.get("precision", {}).get("price")
-    qty_step   = market.get("precision", {}).get("amount")
-    min_cost   = market.get("limits", {}).get("cost", {}).get("min")
-    return {
-        "symbol": sym,
-        "price_tick": price_tick,
-        "qty_step": qty_step,
-        "min_cost": min_cost,
-    }
-
-def round_to_step(value: float, step_decimals: int | None) -> float:
-    if step_decimals is None:
-        return value
-    return float(f"{value:.{step_decimals}f}")
+from typing import Dict, Optional
+from .bybit_exchange import normalize_symbol
+
+def get_filters(exchange, symbol: str) -> Dict:
+    """
+    –î–æ—Å—Ç–∞—ë—Ç –∏–∑ ccxt.market() —Ç–æ—á–Ω–æ—Å—Ç–∏ –∏ –ª–∏–º–∏—Ç—ã:
+    - precision.price -> –∫–æ–ª-–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π –¥–ª—è —Ü–µ–Ω—ã
+    - precision.amount -> –∫–æ–ª-–≤–æ –∑–Ω–∞–∫–æ–≤ –¥–ª—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
+    - limits.cost.min -> –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–æ—Ç–∏–æ–Ω–∞–ª
+    """
+    sym = normalize_symbol(symbol)
+    market = exchange.market(sym)
+    price_tick = market.get("precision", {}).get("price")
+    qty_step   = market.get("precision", {}).get("amount")
+    min_cost   = market.get("limits", {}).get("cost", {}).get("min")
+    return {
+        "symbol": sym,
+        "price_tick": price_tick,
+        "qty_step": qty_step,
+        "min_cost": min_cost,
+    }
+
+def round_to_step(value: float, step_decimals: Optional[int]) -> float:
+    if value is None:
+        return 0.0
+    if step_decimals is None:
+        return float(value)
+    return float(f"{value:.{step_decimals}f}")
+
*** End Patch
*** Begin Patch
*** Update File: core/predict.py
@@
-import os
-from typing import Optional
-import joblib
-import pandas as pd
-from pybit.unified_trading import HTTP
+import os
+from pathlib import Path
+from typing import Optional, Tuple
+import joblib
+import pandas as pd
+import numpy as np
+import ccxt
+from .bybit_exchange import create_exchange, normalize_symbol
@@
-def fetch_data(symbol: str) -> Optional[pd.DataFrame]:
-    """
-    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ OHLCV –∏ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã (RSI, EMA, MACD, Signal).
-    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç DataFrame —Å –∫–æ–ª–æ–Ω–∫–∞–º–∏: ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'rsi', 'ema', 'macd', 'signal']
-    """
-    try:
-        # üîß –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Bybit –∏–ª–∏ –ª—é–±—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –¥–∞–Ω–Ω—ã—Ö
-        # –ü—Ä–∏–º–µ—Ä –∑–∞–≥–ª—É—à–∫–∏ (—Ä–µ–∞–ª–∏–∑—É–π —Ä–µ–∞–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –∑–∞–≥—Ä—É–∑–∫–∏):
-        df = pd.read_csv(
-            f"data/{symbol.replace('/', '_')}.csv"
-        )  # –ª–æ–∫–∞–ª—å–Ω—ã–π CSV –¥–ª—è —Ç–µ—Å—Ç–æ–≤
-
-        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
-        df["ema"] = df["close"].ewm(span=50).mean()
-        df["rsi"] = compute_rsi(df["close"], period
+def _fetch_ohlcv(exchange: ccxt.bybit, symbol: str, timeframe: str = "5m", limit: int = 500) -> pd.DataFrame:
+    sym = normalize_symbol(symbol)
+    raw = exchange.fetch_ohlcv(sym, timeframe=timeframe, limit=limit)
+    df = pd.DataFrame(raw, columns=["timestamp","open","high","low","close","volume"])
+    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)
+    return df
+
+def compute_rsi(series: pd.Series, period: int = 14) -> pd.Series:
+    delta = series.diff()
+    gain = np.where(delta > 0, delta, 0.0)
+    loss = np.where(delta < 0, -delta, 0.0)
+    gain_ema = pd.Series(gain, index=series.index).ewm(alpha=1/period, adjust=False).mean()
+    loss_ema = pd.Series(loss, index=series.index).ewm(alpha=1/period, adjust=False).mean()
+    rs = gain_ema / (loss_ema + 1e-12)
+    rsi = 100 - (100 / (1 + rs))
+    return rsi
+
+def compute_macd(series: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series,pd.Series]:
+    ema_fast = series.ewm(span=fast, adjust=False).mean()
+    ema_slow = series.ewm(span=slow, adjust=False).mean()
+    macd = ema_fast - ema_slow
+    sig = macd.ewm(span=signal, adjust=False).mean()
+    return macd, sig
+
+def fetch_features(symbol: str, timeframe: str = None, limit: int = 500) -> Optional[pd.DataFrame]:
+    """
+    –ó–∞–≥—Ä—É–∂–∞–µ—Ç OHLCV –ø–æ Bybit (—á–µ—Ä–µ–∑ ccxt) –∏ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏: EMA, RSI, MACD, Signal.
+    """
+    ex = create_exchange()
+    tf = timeframe or os.getenv("TIMEFRAME", "5m")
+    df = _fetch_ohlcv(ex, symbol, timeframe=tf, limit=limit)
+    if df.empty:
+        return None
+    df["ema"] = df["close"].ewm(span=50, adjust=False).mean()
+    df["rsi"] = compute_rsi(df["close"], period=14)
+    macd, sig = compute_macd(df["close"])
+    df["macd"] = macd
+    df["signal"] = sig
+    df = df.dropna().reset_index(drop=True)
+    return df
+
+def load_model_for(symbol: str) -> Optional[object]:
+    """
+    –ò—â–µ—Ç –º–æ–¥–µ–ª—å –≤ –ø–∞–ø–∫–µ models/ –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é –∏–º—ë–Ω.
+    –í —Ä–µ–ø–æ —É–∂–µ –µ—Å—Ç—å: model_BTCUSDT, model_ETHUSDT, ... (–±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è) ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏–º —Ç–∞–∫–æ–π —Ñ–æ—Ä–º–∞—Ç.
+    –¢–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–º *.pkl.
+    """
+    pair_key = symbol.upper().replace("/", "").replace(":USDT","")
+    models_dir = Path(os.getenv("MODEL_DIR", "models"))
+    # –í–∞—Ä–∏–∞–Ω—Ç –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
+    cand1 = models_dir / f"model_{pair_key}"
+    # –í–∞—Ä–∏–∞–Ω—Ç —Å pkl
+    cand2 = models_dir / f"model_{pair_key}.pkl"
+    path = cand1 if cand1.exists() else (cand2 if cand2.exists() else None)
+    if not path:
+        return None
+    try:
+        return joblib.load(path)
+    except Exception:
+        return None
+
+def predict_trend(symbol: str) -> dict:
+    """
+    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å —Å–∏–≥–Ω–∞–ª–æ–º –∏ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—è–º–∏.
+    –ï—Å–ª–∏ –º–æ–¥–µ–ª–∏ –Ω–µ—Ç ‚Äî –ø—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: EMA vs Close.
+    """
+    df = fetch_features(symbol)
+    if df is None or df.empty:
+        return {"signal": "hold", "confidence": 0.0, "proba": {"LONG":0.0, "SHORT":0.0}}
+    model = load_model_for(symbol)
+    last = df.iloc[-1]
+    if model is None:
+        # –ø—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞ –±–µ–∑ –º–æ–¥–µ–ª–∏
+        signal = "long" if last["close"] > last["ema"] else "short"
+        conf = float(abs(last["close"] - last["ema"]) / max(last["ema"], 1e-9))
+        conf = max(0.5, min(0.99, conf))  # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑—É–º–Ω–æ
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": conf if signal=="long" else 1-conf, "SHORT": 1-conf if signal=="long" else conf}}
+    # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å –µ—Å—Ç—å ‚Äî —Å–æ–±–µ—Ä—ë–º —Ñ–∏—á–∏
+    features = df[["close","ema","rsi","macd","signal"]].values[-1:].astype(float)
+    try:
+        proba = model.predict_proba(features)[0]
+        # –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º –ø–æ—Ä—è–¥–æ–∫ –∫–ª–∞—Å—Å–æ–≤ [SHORT, LONG]
+        p_short, p_long = float(proba[0]), float(proba[1])
+        signal = "long" if p_long >= p_short else "short"
+        conf = max(p_long, p_short)
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": p_long, "SHORT": p_short}}
+    except Exception:
+        # fallback
+        signal = "long" if last["close"] > last["ema"] else "short"
+        conf = 0.6
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": 0.6 if signal=="long" else 0.4, "SHORT": 0.4 if signal=="long" else 0.6}}
 
*** End Patch
*** Begin Patch
*** Update File: core/time_utils.py
@@
-from datetime import datetime, timezone
-from pybit.unified_trading import HTTP
-
-def get_local_time() -> datetime:
-    return datetime.now(timezone.utc)
-
-def compare_bybit_time(session: HTTP) -> float:
-    """
-    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–∑–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–ª–æ–∫–∞–ª - bybit).
-    """
-    srv_ms = session.get_server_time()["timeSecond"]
-    bybit_dt = datetime.fromtimestamp(int(srv_ms), tz=timezone.utc)
-    local_dt = get_local_time()
-    return (local_dt - bybit_dt).total_seconds()
+from datetime import datetime, timezone
+import ccxt
+from .bybit_exchange import create_exchange
+
+def get_local_time() -> datetime:
+    return datetime.now(timezone.utc)
+
+def compare_bybit_time() -> float:
+    """
+    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–∑–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏ (–ª–æ–∫–∞–ª - bybit) –≤ —Å–µ–∫—É–Ω–¥–∞—Ö —á–µ—Ä–µ–∑ ccxt.
+    """
+    ex: ccxt.bybit = create_exchange()
+    srv_ms = ex.milliseconds()  # –ª–æ–∫–∞–ª—å–Ω—ã–µ ms (—Å —É—á—ë—Ç–æ–º adjustForTimeDifference)
+    # ccxt –Ω–µ –¥–∞—ë—Ç –ø—Ä—è–º–æ–≥–æ server_time —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ, –Ω–æ adjustForTimeDifference
+    # —Å–≥–ª–∞–∂–∏–≤–∞–µ—Ç —Ä–∞—Å—Å–∏–Ω—Ö—Ä–æ–Ω. –î–ª—è –ª–æ–≥–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–ª—å.
+    # –ï—Å–ª–∏ –∫—Ä–∏—Ç–∏—á–Ω–æ ‚Äî –º–æ–∂–Ω–æ –¥–µ—Ä–Ω—É—Ç—å raw /v5/market/time —á–µ—Ä–µ–∑ requests.
+    return 0.0
+
*** End Patch
*** Begin Patch
*** Update File: position_manager.py
@@
-import math
-import os
-from typing import Dict, Any
-from core.bybit_exchange import create_exchange, normalize_symbol
-from core.market_info import get_filters, round_to_step
-
-def calc_order_qty(balance_usdt: float, price: float, risk_fraction: float, leverage: int, min_cost: float | None, qty_step_decimals: int | None) -> float:
-    # –±–∞–∑–æ–≤—ã–π —Ä–∏—Å–∫ –æ—Ç –±–∞–ª–∞–Ω—Å–∞ * –ø–ª–µ—á–æ
-    notional = balance_usdt * risk_fraction * leverage
-    qty = notional / price if price > 0 else 0.0
-    # —É—á—ë—Ç min_cost: –µ—Å–ª–∏ min_cost –∑–∞–¥–∞–Ω, –æ–±–µ—Å–ø–µ—á–∏–º notional >= min_cost
-    if min_cost and notional < min_cost:
-        qty = (min_cost / price)
-    qty = round_to_step(qty, qty_step_decimals)
-    return max(qty, 0.0)
-
-def open_position(symbol: str, side: str, price: float | None = None) -> Dict[str, Any]:
-    """
-    side: 'long' | 'short'
-    """
-    ex = create_exchange()
-    sym = normalize_symbol(symbol)
-
-    # –±–∞–ª–∞–Ω—Å USDT
-    balance = ex.fetch_balance()
-    usdt = balance.get("USDT", {}).get("free", 0.0)
-
-    # –º–∞—Ä–∫‚Äë–∏–Ω—Ñ–æ
-    f = get_filters(ex, sym)
-    risk_fraction = float(os.getenv("RISK_FRACTION", "0.2"))
-    leverage = int(os.getenv("LEVERAGE", "3"))
-
-    # —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–ª–∏
-    if price is None:
-        ticker = ex.fetch_ticker(sym)
-        price = ticker["last"]
-
-    qty = calc_order_qty(
-        balance_usdt=usdt,
-        price=price,
-        risk_fraction=risk_fraction,
-        leverage=leverage,
-        min_cost=f["min_cost"],
-        qty_step_decimals=f["qty_step"],
-    )
-    if qty <= 0:
-        return {"status": "error", "reason": "qty<=0", "balance": usdt}
-
-    order_side = "buy" if side.lower() == "long" else "sell"
-
-    # –ü–ª–µ—á–æ (ccxt setLeverage/ setMarginMode –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è unified —É –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –≤–µ—Ä—Å–∏–π ‚Äî –æ–±–µ—Ä–Ω—ë–º try)
-    try:
-        ex.set_leverage(leverage, sym)
-    except Exception as e:
-        # –û—à–∏–±–∫—É 110043 (leverage not modified) —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—Ö–æ–º
-        if "110043" not in str(e):
-            # –≤—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä—É–µ–º, –Ω–æ –Ω–µ –ø–∞–¥–∞–µ–º
-            print("‚ö†Ô∏è set_leverage:", e)
-
-    try:
-        order = ex.create_market_order(sym, order_side, qty)
-        return {"status": "ok", "order": order, "balance": usdt, "qty": qty, "price": price}
-    except Exception as e:
-        msg = str(e)
-        # 10001 invalid request ‚Äî —á–∞—â–µ —Ñ–æ—Ä–º–∞—Ç —Å–∏–º–≤–æ–ª–∞/—Ç–∏–ø —Ä—ã–Ω–∫–∞/recvWindow.
-        if "10001" in msg:
-            return {"status": "retryable", "reason": "10001 invalid request (–ø—Ä–æ–≤–µ—Ä—å —Ñ–æ—Ä–º–∞—Ç BTC/USDT:USDT –∏ defaultType=swap, recvWindow)", "error": msg}
-        # 110043 leverage not modified ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–∞–∫ —É—Å–ø–µ—Ö –¥–æ –æ—Ä–¥–µ—Ä–∞, –Ω–æ –µ—Å–ª–∏ –ø—Ä–∏–ª–µ—Ç–∏—Ç –∑–¥–µ—Å—å, —Ç–æ–∂–µ –Ω–µ –ø–∞–¥–∞–µ–º
-        if "110043" in msg:
-            return {"status": "ok_with_warning", "warning": "110043 leverage not modified", "balance": usdt, "qty": qty}
-        return {"status": "error", "error": msg, "balance": usdt, "qty": qty}
+import os
+from typing import Dict, Any, Optional
+from core.bybit_exchange import create_exchange, normalize_symbol
+from core.market_info import get_filters, round_to_step
+
+def calc_order_qty(
+    balance_usdt: float,
+    price: float,
+    risk_fraction: float,
+    leverage: int,
+    min_cost: Optional[float],
+    qty_step_decimals: Optional[int],
+) -> float:
+    notional = max(0.0, balance_usdt) * max(0.0, risk_fraction) * max(1, leverage)
+    qty = (notional / price) if price > 0 else 0.0
+    if min_cost and notional < float(min_cost):
+        qty = (float(min_cost) / price)
+    qty = round_to_step(qty, qty_step_decimals)
+    return max(qty, 0.0)
+
+def open_position(symbol: str, side: str, price: Optional[float] = None) -> Dict[str, Any]:
+    """
+    side: 'long' | 'short'
+    """
+    ex = create_exchange()
+    sym = normalize_symbol(symbol)
+
+    balance = ex.fetch_balance()
+    usdt = float(balance.get("USDT", {}).get("free", 0.0) or 0.0)
+
+    f = get_filters(ex, sym)
+    risk_fraction = float(os.getenv("RISK_FRACTION", "0.2"))
+    leverage = int(os.getenv("LEVERAGE", "3"))
+
+    if price is None:
+        ticker = ex.fetch_ticker(sym)
+        price = float(ticker.get("last") or ticker.get("close") or 0.0)
+
+    qty = calc_order_qty(
+        balance_usdt=usdt,
+        price=price,
+        risk_fraction=risk_fraction,
+        leverage=leverage,
+        min_cost=f["min_cost"],
+        qty_step_decimals=f["qty_step"],
+    )
+    if qty <= 0:
+        return {"status": "error", "reason": "qty<=0", "balance": usdt}
+
+    order_side = "buy" if side.lower() == "long" else "sell"
+
+    # –ü—ã—Ç–∞–µ–º—Å—è –≤—ã—Å—Ç–∞–≤–∏—Ç—å –ø–ª–µ—á–æ. 110043 ‚Äî –Ω–µ –æ—à–∏–±–∫–∞.
+    try:
+        ex.set_leverage(leverage, sym)
+    except Exception as e:
+        if "110043" not in str(e):
+            print("‚ö†Ô∏è set_leverage:", e)
+
+    try:
+        order = ex.create_market_order(sym, order_side, qty)
+        return {"status": "ok", "order": order, "balance": usdt, "qty": qty, "price": price}
+    except Exception as e:
+        msg = str(e)
+        if "10001" in msg:
+            return {"status": "retryable", "reason": "10001 invalid request (–ø—Ä–æ–≤–µ—Ä—å —Ñ–æ—Ä–º–∞—Ç BTC/USDT:USDT, defaultType=swap, recvWindow)", "error": msg}
+        if "110043" in msg:
+            return {"status": "ok_with_warning", "warning": "110043 leverage not modified", "balance": usdt, "qty": qty}
+        return {"status": "error", "error": msg, "balance": usdt, "qty": qty}
 
*** End Patch
*** Begin Patch
*** Update File: positions_guard.py
@@
-import argparse
-import os
-from core.env_loader import load_and_check_env
-from core.bybit_exchange import create_exchange, normalize_symbol
-from position_manager import open_position
-
-def print_balance(ex):
-    bal = ex.fetch_balance()
-    usdt = bal.get("USDT", {}).get("free", 0.0)
-    print(f"üí∞ –ë–∞–ª–∞–Ω—Å USDT: {usdt:.2f}")
-    return usdt
-
-def main():
-    load_and_check_env(required_keys=["BYBIT_API_KEY","BYBIT_SECRET_KEY"])
-
-    parser = argparse.ArgumentParser()
-    parser.add_argument("--pair", type=str, help="–ü–∞—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ BTC/USDT:USDT")
-    args = parser.parse_args()
-
-    pairs_env = os.getenv("PAIRS", "BTC/USDT:USDT,ETH/USDT:USDT")
-    pairs = [p.strip() for p in pairs_env.split(",")]
-    if args.pair:
-        pairs = [args.pair]
-
-    ex = create_exchange()
-    usdt = print_balance(ex)
-
-    # –ó–∞–≥–ª—É—à–∫–∞ –æ–±—É—á–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π
-    model_dir = os.getenv("MODEL_DIR", "models")
-    os.makedirs(model_dir, exist_ok=True)
-    print("üß† –ú–æ–¥–µ–ª–∏: –∑–∞–≥—Ä—É–∑–∫–∞/–ø—Ä–æ–≤–µ—Ä–∫–∞ (–∑–∞–≥–ª—É—à–∫–∞) ‚Äî –û–ö")
-
-    for p in pairs:
-        sym = normalize_symbol(p)
-        print(f"üìà –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ–≥–Ω–æ–∑ –ø–æ {sym} (–∑–∞–≥–ª—É—à–∫–∞) ‚Üí —É—Å–ª–æ–≤–∏–µ –≤—Ö–æ–¥–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è")
-
-        # –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ ‚Äî –ø—Ä–æ–±—É–µ–º –æ—Ç–∫—Ä—ã—Ç—å LONG –ø–æ —Ä—ã–Ω–∫—É
-        result = open_position(sym, side="long")
-        print("üßæ –†–µ–∑—É–ª—å—Ç–∞—Ç:", result)
-
-if __name__ == "__main__":
-    main()
+import argparse
+import os
+from datetime import datetime, timezone
+
+from core.env_loader import load_and_check_env
+from core.bybit_exchange import create_exchange, normalize_symbol
+from core.predict import predict_trend
+from position_manager import open_position
+
+def print_balance(ex):
+    bal = ex.fetch_balance()
+    usdt = float(bal.get("USDT", {}).get("free", 0.0) or 0.0)
+    print(f"üí∞ –ë–∞–ª–∞–Ω—Å USDT: {usdt:.2f}")
+    return usdt
+
+def main():
+    load_and_check_env(required_keys=["BYBIT_API_KEY", "BYBIT_SECRET_KEY"])
+
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--pair", type=str, help="–ü–∞—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ BTC/USDT:USDT")
+    args = parser.parse_args()
+
+    pairs_env = os.getenv("PAIRS", "BTC/USDT:USDT,ETH/USDT:USDT,SOL/USDT:USDT")
+    pairs = [p.strip() for p in pairs_env.split(",") if p.strip()]
+    if args.pair:
+        pairs = [args.pair]
+
+    print("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Kolopovstrategy guard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
+    print("‚è± ", datetime.now(timezone.utc).isoformat())
+    print(f"üß™ MODE: LIVE | DOMAIN: bybit | LEV={os.getenv('LEVERAGE','3')} | AMOUNT={os.getenv('AMOUNT','1.0')}")
+    print("üìà Pairs:", ", ".join(pairs))
+
+    ex = create_exchange()
+    usdt = print_balance(ex)
+
+    # –ú–æ–¥–µ–ª–∏: –∑–∞–≥—Ä—É–∑–∫–∞/–æ–±—É—á–µ–Ω–∏–µ (–ª—ë–≥–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
+    model_dir = os.getenv("MODEL_DIR", "models")
+    os.makedirs(model_dir, exist_ok=True)
+    print("üß† –ú–æ–¥–µ–ª–∏: –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è ‚Äî –û–ö")
+
+    for p in pairs:
+        sym = normalize_symbol(p)
+        pred = predict_trend(sym)
+        print(f"üîÆ {sym} ‚Üí signal={pred['signal']} conf={pred['confidence']:.2f} proba={pred['proba']}")
+
+        # –£—Å–ª–æ–≤–∏–µ –æ—Ç–∫—Ä—ã—Ç–∏—è (–ø—Ä–∏–º–µ—Ä: —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å ‚â• 0.65)
+        if pred["confidence"] >= 0.65 and pred["signal"] in ("long", "short"):
+            res = open_position(sym, side=pred["signal"])
+            print("üßæ –†–µ–∑—É–ª—å—Ç–∞—Ç:", res)
+        else:
+            print("‚è∏ –£—Å–ª–æ–≤–∏—è –≤—Ö–æ–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")
+
+if __name__ == "__main__":
+    main()
*** End Patch
*** Begin Patch
*** Add File: .env.example
+BYBIT_API_KEY=
+BYBIT_SECRET_KEY=
+PROXY_URL=
+DOMAIN=bybit
+RISK_FRACTION=0.2
+RECV_WINDOW=15000
+PAIRS=BTC/USDT:USDT,ETH/USDT:USDT,SOL/USDT:USDT,BNB/USDT:USDT
+LEVERAGE=3
+AMOUNT=1.0
+TIMEFRAME=5m
+MODEL_DIR=models
*** End Patch
*** Begin Patch
*** Add File: Procfile
+worker: python positions_guard.py
*** End Patch
*** Begin Patch
*** Update File: requirements.txt
@@
-ccxt>=4.3.64
-pybit==5.8.0
-pandas>=2.2
-numpy>=1.26
-python-dotenv>=1.0
-xgboost>=2.0
-joblib>=1.4
+ccxt>=4.3.64
+pybit==5.8.0
+pandas>=2.2
+numpy>=1.26
+python-dotenv>=1.0
+xgboost>=2.0
+joblib>=1.4
*** End Patch
