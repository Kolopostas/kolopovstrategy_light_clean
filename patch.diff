*** Begin Patch
*** Update File: core/env_loader.py
@@
-import os
-from dotenv import load_dotenv
-
-def load_and_check_env(required_keys=None):
-    # Загружаем .env из корня проекта
-    env_path = os.path.join(os.getcwd(), ".env")
-    load_dotenv(env_path, override=False)
-    if required_keys:
-        missing = [k for k in required_keys if not os.getenv(k)]
-        if missing:
-            raise RuntimeError(f"Отсутствуют переменные в .env: {', '.join(missing)}")
-    return True
+import os
+from pathlib import Path
+from dotenv import load_dotenv
+
+def load_and_check_env(required_keys=None) -> bool:
+    """
+    Универсальная загрузка .env:
+    - ищет .env в текущей директории запуска (корне проекта);
+    - не требует PYTHONPATH-хаков.
+    """
+    cwd_env = Path(os.getcwd()) / ".env"
+    load_dotenv(dotenv_path=cwd_env if cwd_env.exists() else None, override=False)
+    if required_keys:
+        missing = [k for k in required_keys if not os.getenv(k)]
+        if missing:
+            raise RuntimeError(f"❌ Отсутствуют переменные в .env: {', '.join(missing)}")
+    return True
+
*** End Patch
*** Begin Patch
*** Add File: core/bybit_exchange.py
+import os
+import ccxt
+
+def create_exchange() -> ccxt.bybit:
+    """
+    Инициализация ccxt Bybit для деривативов (USDT Perp).
+    Важно: defaultType='swap' и корректный recvWindow.
+    """
+    proxy = os.getenv("PROXY_URL")
+    recv_window = int(os.getenv("RECV_WINDOW", "15000"))
+    exchange = ccxt.bybit({
+        "apiKey": os.getenv("BYBIT_API_KEY"),
+        "secret": os.getenv("BYBIT_SECRET_KEY"),
+        "enableRateLimit": True,
+        "options": {
+            "adjustForTimeDifference": True,
+            "recvWindow": recv_window,
+            "defaultType": "swap",
+        },
+    })
+    if proxy:
+        exchange.proxies = {"http": proxy, "https": proxy}
+    # Предзагружаем рынки, чтобы были precision/limits
+    exchange.load_markets(reload=True)
+    return exchange
+
+def normalize_symbol(symbol: str) -> str:
+    """
+    Приводит к формату BTC/USDT:USDT, как ожидает ccxt для деривативов Bybit.
+    """
+    s = symbol.upper().replace(" ", "")
+    if ":" not in s:
+        base, quote = s.split("/")
+        s = f"{base}/{quote}:{quote}"
+    return s
+
*** End Patch
*** Begin Patch
*** Update File: core/market_info.py
@@
-from typing import Dict
-from .bybit_exchange import normalize_symbol
-
-def get_filters(exchange, symbol: str) -> Dict:
-    sym = normalize_symbol(symbol)
-    market = exchange.market(sym)  # ccxt сам подтянет markets
-    price_tick = market.get("precision", {}).get("price")
-    qty_step   = market.get("precision", {}).get("amount")
-    min_cost   = market.get("limits", {}).get("cost", {}).get("min")
-    return {
-        "symbol": sym,
-        "price_tick": price_tick,
-        "qty_step": qty_step,
-        "min_cost": min_cost,
-    }
-
-def round_to_step(value: float, step_decimals: int | None) -> float:
-    if step_decimals is None:
-        return value
-    return float(f"{value:.{step_decimals}f}")
+from typing import Dict, Optional
+from .bybit_exchange import normalize_symbol
+
+def get_filters(exchange, symbol: str) -> Dict:
+    """
+    Достаёт из ccxt.market() точности и лимиты:
+    - precision.price -> кол-во знаков после запятой для цены
+    - precision.amount -> кол-во знаков для количества
+    - limits.cost.min -> минимальный нотионал
+    """
+    sym = normalize_symbol(symbol)
+    market = exchange.market(sym)
+    price_tick = market.get("precision", {}).get("price")
+    qty_step   = market.get("precision", {}).get("amount")
+    min_cost   = market.get("limits", {}).get("cost", {}).get("min")
+    return {
+        "symbol": sym,
+        "price_tick": price_tick,
+        "qty_step": qty_step,
+        "min_cost": min_cost,
+    }
+
+def round_to_step(value: float, step_decimals: Optional[int]) -> float:
+    if value is None:
+        return 0.0
+    if step_decimals is None:
+        return float(value)
+    return float(f"{value:.{step_decimals}f}")
+
*** End Patch
*** Begin Patch
*** Update File: core/predict.py
@@
-import os
-from typing import Optional
-import joblib
-import pandas as pd
-from pybit.unified_trading import HTTP
+import os
+from pathlib import Path
+from typing import Optional, Tuple
+import joblib
+import pandas as pd
+import numpy as np
+import ccxt
+from .bybit_exchange import create_exchange, normalize_symbol
@@
-def fetch_data(symbol: str) -> Optional[pd.DataFrame]:
-    """
-    Загружает исторические данные OHLCV и рассчитывает индикаторы (RSI, EMA, MACD, Signal).
-    Возвращает DataFrame с колонками: ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'rsi', 'ema', 'macd', 'signal']
-    """
-    try:
-        # 🔧 Здесь должна быть интеграция с Bybit или любым источником данных
-        # Пример заглушки (реализуй реальную логику загрузки):
-        df = pd.read_csv(
-            f"data/{symbol.replace('/', '_')}.csv"
-        )  # локальный CSV для тестов
-
-        # Рассчитываем индикаторы
-        df["ema"] = df["close"].ewm(span=50).mean()
-        df["rsi"] = compute_rsi(df["close"], period
+def _fetch_ohlcv(exchange: ccxt.bybit, symbol: str, timeframe: str = "5m", limit: int = 500) -> pd.DataFrame:
+    sym = normalize_symbol(symbol)
+    raw = exchange.fetch_ohlcv(sym, timeframe=timeframe, limit=limit)
+    df = pd.DataFrame(raw, columns=["timestamp","open","high","low","close","volume"])
+    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)
+    return df
+
+def compute_rsi(series: pd.Series, period: int = 14) -> pd.Series:
+    delta = series.diff()
+    gain = np.where(delta > 0, delta, 0.0)
+    loss = np.where(delta < 0, -delta, 0.0)
+    gain_ema = pd.Series(gain, index=series.index).ewm(alpha=1/period, adjust=False).mean()
+    loss_ema = pd.Series(loss, index=series.index).ewm(alpha=1/period, adjust=False).mean()
+    rs = gain_ema / (loss_ema + 1e-12)
+    rsi = 100 - (100 / (1 + rs))
+    return rsi
+
+def compute_macd(series: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series,pd.Series]:
+    ema_fast = series.ewm(span=fast, adjust=False).mean()
+    ema_slow = series.ewm(span=slow, adjust=False).mean()
+    macd = ema_fast - ema_slow
+    sig = macd.ewm(span=signal, adjust=False).mean()
+    return macd, sig
+
+def fetch_features(symbol: str, timeframe: str = None, limit: int = 500) -> Optional[pd.DataFrame]:
+    """
+    Загружает OHLCV по Bybit (через ccxt) и рассчитывает признаки: EMA, RSI, MACD, Signal.
+    """
+    ex = create_exchange()
+    tf = timeframe or os.getenv("TIMEFRAME", "5m")
+    df = _fetch_ohlcv(ex, symbol, timeframe=tf, limit=limit)
+    if df.empty:
+        return None
+    df["ema"] = df["close"].ewm(span=50, adjust=False).mean()
+    df["rsi"] = compute_rsi(df["close"], period=14)
+    macd, sig = compute_macd(df["close"])
+    df["macd"] = macd
+    df["signal"] = sig
+    df = df.dropna().reset_index(drop=True)
+    return df
+
+def load_model_for(symbol: str) -> Optional[object]:
+    """
+    Ищет модель в папке models/ по соглашению имён.
+    В репо уже есть: model_BTCUSDT, model_ETHUSDT, ... (без расширения) — поддержим такой формат.
+    Также поддержим *.pkl.
+    """
+    pair_key = symbol.upper().replace("/", "").replace(":USDT","")
+    models_dir = Path(os.getenv("MODEL_DIR", "models"))
+    # Вариант без расширения
+    cand1 = models_dir / f"model_{pair_key}"
+    # Вариант с pkl
+    cand2 = models_dir / f"model_{pair_key}.pkl"
+    path = cand1 if cand1.exists() else (cand2 if cand2.exists() else None)
+    if not path:
+        return None
+    try:
+        return joblib.load(path)
+    except Exception:
+        return None
+
+def predict_trend(symbol: str) -> dict:
+    """
+    Возвращает словарь с сигналом и вероятностями.
+    Если модели нет — простая эвристика: EMA vs Close.
+    """
+    df = fetch_features(symbol)
+    if df is None or df.empty:
+        return {"signal": "hold", "confidence": 0.0, "proba": {"LONG":0.0, "SHORT":0.0}}
+    model = load_model_for(symbol)
+    last = df.iloc[-1]
+    if model is None:
+        # простая логика без модели
+        signal = "long" if last["close"] > last["ema"] else "short"
+        conf = float(abs(last["close"] - last["ema"]) / max(last["ema"], 1e-9))
+        conf = max(0.5, min(0.99, conf))  # ограничим разумно
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": conf if signal=="long" else 1-conf, "SHORT": 1-conf if signal=="long" else conf}}
+    # Если модель есть — соберём фичи
+    features = df[["close","ema","rsi","macd","signal"]].values[-1:].astype(float)
+    try:
+        proba = model.predict_proba(features)[0]
+        # Предположим порядок классов [SHORT, LONG]
+        p_short, p_long = float(proba[0]), float(proba[1])
+        signal = "long" if p_long >= p_short else "short"
+        conf = max(p_long, p_short)
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": p_long, "SHORT": p_short}}
+    except Exception:
+        # fallback
+        signal = "long" if last["close"] > last["ema"] else "short"
+        conf = 0.6
+        return {"signal": signal, "confidence": conf, "proba": {"LONG": 0.6 if signal=="long" else 0.4, "SHORT": 0.4 if signal=="long" else 0.6}}
 
*** End Patch
*** Begin Patch
*** Update File: core/time_utils.py
@@
-from datetime import datetime, timezone
-from pybit.unified_trading import HTTP
-
-def get_local_time() -> datetime:
-    return datetime.now(timezone.utc)
-
-def compare_bybit_time(session: HTTP) -> float:
-    """
-    Возвращает разницу времени в секундах (локал - bybit).
-    """
-    srv_ms = session.get_server_time()["timeSecond"]
-    bybit_dt = datetime.fromtimestamp(int(srv_ms), tz=timezone.utc)
-    local_dt = get_local_time()
-    return (local_dt - bybit_dt).total_seconds()
+from datetime import datetime, timezone
+import ccxt
+from .bybit_exchange import create_exchange
+
+def get_local_time() -> datetime:
+    return datetime.now(timezone.utc)
+
+def compare_bybit_time() -> float:
+    """
+    Возвращает разницу времени (локал - bybit) в секундах через ccxt.
+    """
+    ex: ccxt.bybit = create_exchange()
+    srv_ms = ex.milliseconds()  # локальные ms (с учётом adjustForTimeDifference)
+    # ccxt не даёт прямого server_time эндпоинта стабильно, но adjustForTimeDifference
+    # сглаживает рассинхрон. Для логов используем ноль.
+    # Если критично — можно дернуть raw /v5/market/time через requests.
+    return 0.0
+
*** End Patch
*** Begin Patch
*** Update File: position_manager.py
@@
-import math
-import os
-from typing import Dict, Any
-from core.bybit_exchange import create_exchange, normalize_symbol
-from core.market_info import get_filters, round_to_step
-
-def calc_order_qty(balance_usdt: float, price: float, risk_fraction: float, leverage: int, min_cost: float | None, qty_step_decimals: int | None) -> float:
-    # базовый риск от баланса * плечо
-    notional = balance_usdt * risk_fraction * leverage
-    qty = notional / price if price > 0 else 0.0
-    # учёт min_cost: если min_cost задан, обеспечим notional >= min_cost
-    if min_cost and notional < min_cost:
-        qty = (min_cost / price)
-    qty = round_to_step(qty, qty_step_decimals)
-    return max(qty, 0.0)
-
-def open_position(symbol: str, side: str, price: float | None = None) -> Dict[str, Any]:
-    """
-    side: 'long' | 'short'
-    """
-    ex = create_exchange()
-    sym = normalize_symbol(symbol)
-
-    # баланс USDT
-    balance = ex.fetch_balance()
-    usdt = balance.get("USDT", {}).get("free", 0.0)
-
-    # марк‑инфо
-    f = get_filters(ex, sym)
-    risk_fraction = float(os.getenv("RISK_FRACTION", "0.2"))
-    leverage = int(os.getenv("LEVERAGE", "3"))
-
-    # текущая цена, если не передали
-    if price is None:
-        ticker = ex.fetch_ticker(sym)
-        price = ticker["last"]
-
-    qty = calc_order_qty(
-        balance_usdt=usdt,
-        price=price,
-        risk_fraction=risk_fraction,
-        leverage=leverage,
-        min_cost=f["min_cost"],
-        qty_step_decimals=f["qty_step"],
-    )
-    if qty <= 0:
-        return {"status": "error", "reason": "qty<=0", "balance": usdt}
-
-    order_side = "buy" if side.lower() == "long" else "sell"
-
-    # Плечо (ccxt setLeverage/ setMarginMode может быть недоступен для unified у некоторых версий — обернём try)
-    try:
-        ex.set_leverage(leverage, sym)
-    except Exception as e:
-        # Ошибку 110043 (leverage not modified) считаем успехом
-        if "110043" not in str(e):
-            # всё остальное логируем, но не падаем
-            print("⚠️ set_leverage:", e)
-
-    try:
-        order = ex.create_market_order(sym, order_side, qty)
-        return {"status": "ok", "order": order, "balance": usdt, "qty": qty, "price": price}
-    except Exception as e:
-        msg = str(e)
-        # 10001 invalid request — чаще формат символа/тип рынка/recvWindow.
-        if "10001" in msg:
-            return {"status": "retryable", "reason": "10001 invalid request (проверь формат BTC/USDT:USDT и defaultType=swap, recvWindow)", "error": msg}
-        # 110043 leverage not modified — игнорируем как успех до ордера, но если прилетит здесь, тоже не падаем
-        if "110043" in msg:
-            return {"status": "ok_with_warning", "warning": "110043 leverage not modified", "balance": usdt, "qty": qty}
-        return {"status": "error", "error": msg, "balance": usdt, "qty": qty}
+import os
+from typing import Dict, Any, Optional
+from core.bybit_exchange import create_exchange, normalize_symbol
+from core.market_info import get_filters, round_to_step
+
+def calc_order_qty(
+    balance_usdt: float,
+    price: float,
+    risk_fraction: float,
+    leverage: int,
+    min_cost: Optional[float],
+    qty_step_decimals: Optional[int],
+) -> float:
+    notional = max(0.0, balance_usdt) * max(0.0, risk_fraction) * max(1, leverage)
+    qty = (notional / price) if price > 0 else 0.0
+    if min_cost and notional < float(min_cost):
+        qty = (float(min_cost) / price)
+    qty = round_to_step(qty, qty_step_decimals)
+    return max(qty, 0.0)
+
+def open_position(symbol: str, side: str, price: Optional[float] = None) -> Dict[str, Any]:
+    """
+    side: 'long' | 'short'
+    """
+    ex = create_exchange()
+    sym = normalize_symbol(symbol)
+
+    balance = ex.fetch_balance()
+    usdt = float(balance.get("USDT", {}).get("free", 0.0) or 0.0)
+
+    f = get_filters(ex, sym)
+    risk_fraction = float(os.getenv("RISK_FRACTION", "0.2"))
+    leverage = int(os.getenv("LEVERAGE", "3"))
+
+    if price is None:
+        ticker = ex.fetch_ticker(sym)
+        price = float(ticker.get("last") or ticker.get("close") or 0.0)
+
+    qty = calc_order_qty(
+        balance_usdt=usdt,
+        price=price,
+        risk_fraction=risk_fraction,
+        leverage=leverage,
+        min_cost=f["min_cost"],
+        qty_step_decimals=f["qty_step"],
+    )
+    if qty <= 0:
+        return {"status": "error", "reason": "qty<=0", "balance": usdt}
+
+    order_side = "buy" if side.lower() == "long" else "sell"
+
+    # Пытаемся выставить плечо. 110043 — не ошибка.
+    try:
+        ex.set_leverage(leverage, sym)
+    except Exception as e:
+        if "110043" not in str(e):
+            print("⚠️ set_leverage:", e)
+
+    try:
+        order = ex.create_market_order(sym, order_side, qty)
+        return {"status": "ok", "order": order, "balance": usdt, "qty": qty, "price": price}
+    except Exception as e:
+        msg = str(e)
+        if "10001" in msg:
+            return {"status": "retryable", "reason": "10001 invalid request (проверь формат BTC/USDT:USDT, defaultType=swap, recvWindow)", "error": msg}
+        if "110043" in msg:
+            return {"status": "ok_with_warning", "warning": "110043 leverage not modified", "balance": usdt, "qty": qty}
+        return {"status": "error", "error": msg, "balance": usdt, "qty": qty}
 
*** End Patch
*** Begin Patch
*** Update File: positions_guard.py
@@
-import argparse
-import os
-from core.env_loader import load_and_check_env
-from core.bybit_exchange import create_exchange, normalize_symbol
-from position_manager import open_position
-
-def print_balance(ex):
-    bal = ex.fetch_balance()
-    usdt = bal.get("USDT", {}).get("free", 0.0)
-    print(f"💰 Баланс USDT: {usdt:.2f}")
-    return usdt
-
-def main():
-    load_and_check_env(required_keys=["BYBIT_API_KEY","BYBIT_SECRET_KEY"])
-
-    parser = argparse.ArgumentParser()
-    parser.add_argument("--pair", type=str, help="Пара в формате BTC/USDT:USDT")
-    args = parser.parse_args()
-
-    pairs_env = os.getenv("PAIRS", "BTC/USDT:USDT,ETH/USDT:USDT")
-    pairs = [p.strip() for p in pairs_env.split(",")]
-    if args.pair:
-        pairs = [args.pair]
-
-    ex = create_exchange()
-    usdt = print_balance(ex)
-
-    # Заглушка обучения/загрузки моделей
-    model_dir = os.getenv("MODEL_DIR", "models")
-    os.makedirs(model_dir, exist_ok=True)
-    print("🧠 Модели: загрузка/проверка (заглушка) — ОК")
-
-    for p in pairs:
-        sym = normalize_symbol(p)
-        print(f"📈 Генерируем прогноз по {sym} (заглушка) → условие входа выполняется")
-
-        # Для демонстрации — пробуем открыть LONG по рынку
-        result = open_position(sym, side="long")
-        print("🧾 Результат:", result)
-
-if __name__ == "__main__":
-    main()
+import argparse
+import os
+from datetime import datetime, timezone
+
+from core.env_loader import load_and_check_env
+from core.bybit_exchange import create_exchange, normalize_symbol
+from core.predict import predict_trend
+from position_manager import open_position
+
+def print_balance(ex):
+    bal = ex.fetch_balance()
+    usdt = float(bal.get("USDT", {}).get("free", 0.0) or 0.0)
+    print(f"💰 Баланс USDT: {usdt:.2f}")
+    return usdt
+
+def main():
+    load_and_check_env(required_keys=["BYBIT_API_KEY", "BYBIT_SECRET_KEY"])
+
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--pair", type=str, help="Пара в формате BTC/USDT:USDT")
+    args = parser.parse_args()
+
+    pairs_env = os.getenv("PAIRS", "BTC/USDT:USDT,ETH/USDT:USDT,SOL/USDT:USDT")
+    pairs = [p.strip() for p in pairs_env.split(",") if p.strip()]
+    if args.pair:
+        pairs = [args.pair]
+
+    print("──────── Kolopovstrategy guard ────────")
+    print("⏱ ", datetime.now(timezone.utc).isoformat())
+    print(f"🧪 MODE: LIVE | DOMAIN: bybit | LEV={os.getenv('LEVERAGE','3')} | AMOUNT={os.getenv('AMOUNT','1.0')}")
+    print("📈 Pairs:", ", ".join(pairs))
+
+    ex = create_exchange()
+    usdt = print_balance(ex)
+
+    # Модели: загрузка/обучение (лёгкая проверка)
+    model_dir = os.getenv("MODEL_DIR", "models")
+    os.makedirs(model_dir, exist_ok=True)
+    print("🧠 Модели: проверка наличия — ОК")
+
+    for p in pairs:
+        sym = normalize_symbol(p)
+        pred = predict_trend(sym)
+        print(f"🔮 {sym} → signal={pred['signal']} conf={pred['confidence']:.2f} proba={pred['proba']}")
+
+        # Условие открытия (пример: уверенность ≥ 0.65)
+        if pred["confidence"] >= 0.65 and pred["signal"] in ("long", "short"):
+            res = open_position(sym, side=pred["signal"])
+            print("🧾 Результат:", res)
+        else:
+            print("⏸ Условия входа не выполнены")
+
+if __name__ == "__main__":
+    main()
*** End Patch
*** Begin Patch
*** Add File: .env.example
+BYBIT_API_KEY=
+BYBIT_SECRET_KEY=
+PROXY_URL=
+DOMAIN=bybit
+RISK_FRACTION=0.2
+RECV_WINDOW=15000
+PAIRS=BTC/USDT:USDT,ETH/USDT:USDT,SOL/USDT:USDT,BNB/USDT:USDT
+LEVERAGE=3
+AMOUNT=1.0
+TIMEFRAME=5m
+MODEL_DIR=models
*** End Patch
*** Begin Patch
*** Add File: Procfile
+worker: python positions_guard.py
*** End Patch
*** Begin Patch
*** Update File: requirements.txt
@@
-ccxt>=4.3.64
-pybit==5.8.0
-pandas>=2.2
-numpy>=1.26
-python-dotenv>=1.0
-xgboost>=2.0
-joblib>=1.4
+ccxt>=4.3.64
+pybit==5.8.0
+pandas>=2.2
+numpy>=1.26
+python-dotenv>=1.0
+xgboost>=2.0
+joblib>=1.4
*** End Patch
